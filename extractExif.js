import fs from 'fs/promises';
import path from 'path';
import exifr from 'exifr';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// To handle __dirname in ES module
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Since exifr is a CommonJS module, we directly use it without destructuring
const parse = exifr.parse;

// Define the path to the directories
const originalsDir = path.join(__dirname, 'public', 'images', 'originals');
const fullsDir = './images/fulls';
const thumbnailsDir = './images/thumbnails';

// Base URL for Imgix
const imgixBaseUrl = 'https://sfmta-test-975080756.imgix.net';

// Function to read all files in the directory
async function readFiles(directory) {
    return fs.readdir(directory, { withFileTypes: true });
}

// Function to generate the desired object structure for each image
async function generateImageData(files) {
    const imageData = [];
    for (const file of files) {
        if (file.isFile() && /\.(jpg|jpeg|png|tiff)$/i.test(file.name)) {
            try {
                // Modify this part of the generateImageData function to ensure correct extraction
                const originalPath = path.join(originalsDir, file.name);

                // exifr.parse(originalPath, { iptc: true }).then(metadata => {
                //     console.log(metadata); // See if any metadata is extracted
                // });

                // Request IPTC data along with EXIF by specifying the iptc option in parse method
                const options = { iptc: true };
                // Ensure IPTC data is also extracted by specifying it in the options
                const metadata = await exifr.parse(originalPath, { iptc: true });

                // Generate Imgix URLs
                const imgixOriginal = `${imgixBaseUrl}/originals/${file.name}?wm=webp&lossless=0`;
                const imgixFull = `${imgixBaseUrl}/fulls/${file.name}?wm=webp&lossless=0`;
                const imgixThumbnail = `${imgixBaseUrl}/thumbnails/${file.name}?wm=webp&lossless=0`;

                imageData.push({
                    original: path.join('./images/originals', file.name),
                    full: path.join(fullsDir, file.name),
                    thumbnail: path.join(thumbnailsDir, file.name),
                    imgixOriginal, // Add the new Imgix URL
                    imgixFull, // Add the new Imgix URL
                    imgixThumbnail, // Add the new Imgix URL
                    title: "", // Title can be extracted or defined here
                    description: "", // Description can be extracted or defined here
                    exif: metadata || {}, // Safely fallback to an empty object if undefined
                    // iptc: metadata.iptc || {}, // Safely fallback to an empty object if undefined

                });
            } catch (error) {
                console.error(`Error extracting metadata from ${file.name}: ${error}`);
            }
        }
    }
    return imageData;
}

// Function to update imageData objects with new DateTimeOriginal values. The values will be generated by parsing the end of the string imgData.exif.Caption
// imgData.exif.Caption always ends with a pipe character followed by a date formatted like: July 1903
// I want you to convert this to format like this 1903-07-01T13:00:00.000Z

function updateImageDataWithDateTimeOriginal(imageData) {
    return imageData.map(imgData => {
        // Extract the date from imgData.exif.Caption
        const caption = imgData.exif.Caption || '';  
        const sourceDate = caption.split('|')[1];

        const date = sourceDate ? new Date(sourceDate) : new Date(0);
        // Update imgData with the new DateTimeOriginal value
        return {
            ...imgData,
            exif: {
                ...imgData.exif,
                DateTimeOriginal: date.toISOString(),
            },
        };
    });
}

// Function to sort imageData by DateTimeOriginal
function sortByDateTimeOriginal(imageData) {
    return imageData.sort((a, b) => {
        // Check if exif data exists and has DateTimeOriginal; use a fallback value if not
        const dateA = a.exif && a.exif.DateTimeOriginal ? new Date(a.exif.DateTimeOriginal) : new Date(0);
        const dateB = b.exif && b.exif.DateTimeOriginal ? new Date(b.exif.DateTimeOriginal) : new Date(0);
        return dateA - dateB;
    });
}


// Main function to execute the script
async function main() {
    try {
        const files = await readFiles(originalsDir);
        let imageData = await generateImageData(files);
        // update imageData with DateTimeOriginal values
        const updatedimageData = updateImageDataWithDateTimeOriginal(imageData);
        imageData = sortByDateTimeOriginal(updatedimageData); // Sort imageData before writing
        await fs.writeFile(path.join(__dirname, 'imageData.json'), JSON.stringify(imageData, null, 2));
        console.log('Image data extraction complete and saved to imageData.json');
    } catch (error) {
        console.error('Failed to extract image data:', error);
    }
}

// Run the main function
main();
